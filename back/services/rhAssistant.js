// ü§ñ rhAssistant.js - Corrig√© pour API Mistral AI
const fs = require("fs").promises;
const path = require("path");
const axios = require("axios");
const pdf = require('pdf-parse');
const mammoth = require('mammoth');
const NodeCache = require("node-cache");
require("dotenv").config();

// Configuration Mistral
const MISTRAL_API_KEY = process.env.MISTRAL_API_KEY;
const MISTRAL_BASE_URL = "https://api.mistral.ai/v1";
const CONVERSATION_CACHE = new NodeCache({ stdTTL: 7200 }); // 2 heures

// üß† GESTIONNAIRE DE M√âMOIRE PERSISTANTE
class MemoryManager {
  constructor() {
    this.conversations = new Map();
    this.cleanupInterval = 30 * 60 * 1000; // 30 minutes
    this.maxConversationAge = 7200 * 1000; // 2 heures (m√™me que NodeCache)
    this.startCleanup();
  }

  getOrCreateConversation(userId) {
    if (!this.conversations.has(userId)) {
      this.conversations.set(userId, {
        memory: new ConversationMemory(userId),
        lastActivity: Date.now(),
      });
    } else {
      this.conversations.get(userId).lastActivity = Date.now();
    }
    return this.conversations.get(userId).memory;
  }

  startCleanup() {
    setInterval(() => {
      const now = Date.now();
      for (const [userId, conversation] of this.conversations.entries()) {
        if (now - conversation.lastActivity > this.maxConversationAge) {
          this.conversations.delete(userId);
        }
      }
    }, this.cleanupInterval);
  }
}

// Instance globale du gestionnaire de m√©moire
const memoryManager = new MemoryManager();

// Chemins des fichiers de donn√©es
const FAQ_PATH = path.join(__dirname, "../data/faq_rh_questions.json");
const JOBS_PATH = path.join(__dirname, "../data/job_offers.json");
const CANDIDATES_PATH = path.join(__dirname, "../data/candidates.json");

// üíæ GESTION DE LA M√âMOIRE DE CONVERSATION
class ConversationMemory {
  constructor(userId) {
    this.userId = userId;
    this.context = {
      history: [],
      sessionStart: Date.now(),
      extractedFileData: null,
      requestType: null,
    };
  }

  addMessage(role, content) {
    const message = {
      role,
      content,
      timestamp: Date.now(),
    };

    this.context.history.push(message);

    // Limiter √† 15 messages pour √©viter les tokens excessifs
    if (this.context.history.length > 15) {
      this.context.history = this.context.history.slice(-15);
    }

    this.save();
  }

  setFileData(fileData) {
    this.context.extractedFileData = fileData;
    this.save();
  }

  setRequestType(type) {
    this.context.requestType = type;
    this.save();
  }

  getRecentHistory(maxMessages = 6) {
    return this.context.history
      .slice(-maxMessages)
      .map((msg) => `${msg.role}: ${msg.content}`)
      .join("\n");
  }

  // Retourne l'historique au format Mistral
  getMistralHistory(maxMessages = 6) {
    return this.context.history.slice(-maxMessages).map((msg) => ({
      role: msg.role === "user" ? "user" : "assistant",
      content: msg.content,
    }));
  }

  save() {
    CONVERSATION_CACHE.set(this.userId, this.context);
  }

  getContext() {
    return this.context;
  }
}

// üìö CHARGEMENT DES DONN√âES
async function loadKnowledgeBase() {
  try {
    const [faqData, jobsData, candidatesData] = await Promise.all([
      fs
        .readFile(FAQ_PATH, "utf-8")
        .then(JSON.parse)
        .catch(() => []),
      // fs
      //   .readFile(JOBS_PATH, "utf-8")
      //   .then(JSON.parse)
      //   .catch(() => []),
      fs
        .readFile(CANDIDATES_PATH, "utf-8")
        .then(JSON.parse)
        .catch(() => []),
    ]);

    return { faqData, jobsData, candidatesData };
  } catch (error) {
    console.error("‚ùå Erreur chargement base de connaissance:", error);
    return { faqData: [], jobsData: [], candidatesData: [] };
  }
}

// üéØ ANALYSE DU TYPE DE DEMANDE
function analyzeRequestType(userMessage) {
  const message = userMessage.toLowerCase();

  const jobIndicators = [
    "emploi",
    "poste",
    "travail",
    "offre",
    "recrutement",
    "embauche",
    "cherche travail",
    "recherche emploi",
    "candidature",
    "postuler",
    "job",
    "boulot",
    "mission",
    "cdd",
    "cdi",
    "interim",
  ];

  const candidateIndicators = [
    "candidat",
    "profil",
    "cv",
    "recruter",
    "personnel",
    "talent",
    "cherche candidat",
    "besoin de",
    "recherche profil",
    "disponible",
    "serveur",
    "cuisinier",
    "chef",
    "barman",
    "r√©ceptionniste",
  ];

  const faqIndicators = [
    "comment",
    "pourquoi",
    "quand",
    "o√π",
    "qui",
    "quoi",
    "proc√©dure",
    "d√©marche",
    "√©tapes",
    "info",
    "renseignement",
    "horaires",
    "contact",
    "adresse",
    "t√©l√©phone",
  ];

  if (jobIndicators.some((indicator) => message.includes(indicator))) {
    return "job_search";
  } else if (
    candidateIndicators.some((indicator) => message.includes(indicator))
  ) {
    return "candidate_search";
  } else if (faqIndicators.some((indicator) => message.includes(indicator))) {
    return "faq";
  }

  return "general";
}

// üîç RECHERCHE DANS LA FAQ
function searchFAQ(userMessage, faqData) {
  if (!Array.isArray(faqData) || faqData.length === 0) {
    return [];
  }

  const cleanMessage = userMessage.toLowerCase();
  const words = cleanMessage.split(/\s+/).filter((word) => word.length > 2);

  const scoredFAQ = faqData
    .map((item) => {
      let score = 0;
      const questionText = (item.question || "").toLowerCase();
      const answerText = (item.answer || item.reponse || "").toLowerCase();
      const tagsText = (item.tags || []).join(" ").toLowerCase();
      const categoryText = (
        item.category ||
        item.categorie ||
        ""
      ).toLowerCase();

      // Score bas√© sur les mots-cl√©s
      words.forEach((word) => {
        if (questionText.includes(word)) score += 4;
        if (answerText.includes(word)) score += 2;
        if (tagsText.includes(word)) score += 3;
        if (categoryText.includes(word)) score += 2;
      });

      // Bonus pour correspondance exacte
      if (questionText.includes(cleanMessage)) score += 10;

      return { ...item, score };
    })
    .filter((item) => item.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, 5);

  return scoredFAQ;
}

// üíº RECHERCHE D'OFFRES D'EMPLOI
function searchJobs(userMessage, jobsData) {
  if (!Array.isArray(jobsData) || jobsData.length === 0) {
    return [];
  }

  const keywords = userMessage
    .toLowerCase()
    .split(/\s+/)
    .filter((word) => word.length > 2);
  const requestType = analyzeRequestType(userMessage);

  const scoredJobs = jobsData
    .map((job) => {
      let score = 0;
      const jobText = [
        job.title || job.intitule || "",
        job.description || job.missions || "",
        job.company || job.entreprise || "",
        job.location || job.lieu || "",
        job.contract || job.contrat || "",
        job.sector || job.secteur || "",
      ]
        .join(" ")
        .toLowerCase();

      keywords.forEach((keyword) => {
        if (jobText.includes(keyword)) score += 2;
      });

      // Bonus si c'est une recherche d'emploi explicite
      if (requestType === "job_search") score += 3;

      // Bonus pour les offres r√©centes
      if (job.datePublication) {
        const jobDate = new Date(job.datePublication);
        const daysSince =
          (Date.now() - jobDate.getTime()) / (1000 * 60 * 60 * 24);
        if (daysSince < 30) score += 2;
      }

      return { ...job, score };
    })
    .filter((job) => job.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, 6);

  return scoredJobs;
}

// üë• RECHERCHE DE CANDIDATS
function searchCandidates(userMessage, candidatesData) {
  if (!Array.isArray(candidatesData) || candidatesData.length === 0) {
    return [];
  }

  const keywords = userMessage
    .toLowerCase()
    .split(/\s+/)
    .filter((word) => word.length > 2);
  const requestType = analyzeRequestType(userMessage);

  const candidateKeywords = [
    "candidat",
    "profil",
    "cv",
    "comp√©tence",
    "exp√©rience",
    "serveur",
    "cuisinier",
    "chef",
    "barman",
    "r√©ceptionniste",
    "manager",
    "h√¥tellerie",
    "restauration",
    "disponible",
    "recruter",
    "embaucher",
    "cherche",
  ];

  const isCandidateSearch =
    candidateKeywords.some((keyword) =>
      userMessage.toLowerCase().includes(keyword)
    ) || requestType === "candidate_search";

  const scoredCandidates = candidatesData
    .map((candidate) => {
      let score = 0;
      const candidateText = [
        candidate.nom || "",
        candidate.prenom || "",
        candidate.poste || candidate.metier || candidate.profession || "",
        candidate.competences || candidate.skills || "",
        candidate.experience || candidate.exp || "",
        candidate.localisation || candidate.ville || candidate.lieu || "",
        candidate.secteur || candidate.domaine || "",
      ]
        .join(" ")
        .toLowerCase();

      keywords.forEach((keyword) => {
        if (candidateText.includes(keyword)) score += 2;
      });

      // Bonus si recherche explicite de candidats
      if (isCandidateSearch) score += 3;

      // Bonus pour disponibilit√© imm√©diate
      if (
        candidate.disponibilite === "imm√©diate" ||
        candidate.availability === "immediate"
      ) {
        score += 2;
      }

      return { ...candidate, score };
    })
    .filter((candidate) => candidate.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, 6);

  // Si recherche explicite mais pas de r√©sultats, retourner quelques candidats
  if (isCandidateSearch && scoredCandidates.length === 0) {
    return candidatesData
      .slice(0, 3)
      .map((candidate) => ({ ...candidate, score: 1 }));
  }

  return scoredCandidates;
}

async function getJobOffers() {
  const url =
    "https://api.honest-inn.com/api/job_offers/search_job_offers_guest";

  try {
    const response = await axios.get(url);
    const jobOffers = response.data; // Suppose que la r√©ponse est en JSON
    return jobOffers;
  } catch (error) {
    console.error("Une erreur s'est produite :", error);
    return null;
  }
}

// ü§ñ G√âN√âRATION DE R√âPONSE AVEC MISTRAL AI
async function generateAIResponse(
  userMessage,
  context,
  knowledgeBase,
  fileData = null
) {
  if (!MISTRAL_API_KEY) {
    return "Service IA temporairement indisponible. Contactez-nous au 01 98 75 90 28.";
  }

  try {
    // Analyser le type de demande
    const requestType = analyzeRequestType(userMessage);

    // Construction du prompt syst√®me optimis√©
    let systemPrompt = `
    - Tu t'appelle Alsi, tu es l'assistante RH virtuelle d'Honest-Inn, une agence de placement.
- t'as le droit d'√©valuer des cvs et de donner ton avis 
INFORMATIONS SUR HONEST-INN:
- Agence de recrutement
- Services: placement CDI/CDD, missions int√©rim, conseil RH
- T√©l√©phone: 01 98 75 90 28
- Email: contact@honest-inn.com
- Horaires: Lundi-Vendredi 9h-18h
- Adresse: 104 rue Gabriel P√©ri, Gentilly

TYPE DE DEMANDE D√âTECT√â: ${requestType}

BASE DE CONNAISSANCE FOURNIE:`;

    // Ajouter le contenu pertinent selon le type de demande
    if (requestType === "faq" || requestType === "general") {
      const relevantFAQ = searchFAQ(userMessage, knowledgeBase.faqData);
      if (relevantFAQ.length > 0) {
        systemPrompt += "\n\nQUESTIONS FR√âQUENTES PERTINENTES:\n";
        relevantFAQ.forEach((faq, index) => {
          systemPrompt += `${index + 1}. Q: ${faq.question}\n   R: ${
            faq.answer || faq.reponse
          }\n`;
          if (faq.tags) systemPrompt += `   Tags: ${faq.tags.join(", ")}\n`;
          systemPrompt += "\n";
        });
      }
    }

    if (requestType === "job_search" || requestType === "general") {
      // Only call getJobOffers() when user is specifically asking for job offers
      const jobOffers = await getJobOffers();
      systemPrompt += `\n\nSi l'utilisateur te demande les offres d'emploi disponibles, r√©cup√®re les offres d'emploi pertinentes et pr√©sente-les de mani√®re concise. N'affiche JAMAIS les missions et le profil recherch√© dans ta r√©ponse. Pour chaque offre, affiche uniquement : titre, entreprise, lieu, contrat, salaire et g√©n√®re un lien cliquable vers l'offre - Voir l'offre compl√®te - vers le lien https://app.honest-inn.com/job_details/[ID_DE_L_OFFRE] : ${JSON.stringify(
        jobOffers,
        null,
        2
      )}`;

      const relevantJobs = searchJobs(userMessage, knowledgeBase.jobsData);
      if (relevantJobs.length > 0) {
        systemPrompt += "\nOFFRES D'EMPLOI DISPONIBLES:\n";
        relevantJobs.forEach((job, index) => {
          systemPrompt += `${index + 1}. ${job.title || job.intitule}
Entreprise: ${job.company || job.entreprise}
Lieu: ${job.location || job.lieu}
Contrat: ${job.contract || job.contrat || job.type || "Non sp√©cifi√©"}
Salaire: ${job.salary || job.salaire || "√Ä n√©gocier"}
Contact: Via agence Honest-Inn\n\n`;
        });
      }
    }

    if (requestType === "candidate_search" || requestType === "general") {
      const relevantCandidates = searchCandidates(
        userMessage,
        knowledgeBase.candidatesData
      );
      if (relevantCandidates.length > 0) {
        systemPrompt += "\nPROFILS CANDIDATS DISPONIBLES:\n";
        relevantCandidates.forEach((candidate, index) => {
          systemPrompt += `${index + 1}. ${candidate.prenom || ""} ${(
            candidate.nom || ""
          ).charAt(0)}.
   Poste recherch√©: ${
     candidate.poste ||
     candidate.metier ||
     candidate.profession ||
     "Non sp√©cifi√©"
   }
   Exp√©rience: ${candidate.experience || candidate.exp || "Non sp√©cifi√©e"}
   Localisation: ${
     candidate.localisation ||
     candidate.ville ||
     candidate.lieu ||
     "Non sp√©cifi√©e"
   }
   Comp√©tences: ${candidate.competences || candidate.skills || "Non sp√©cifi√©es"}
   Disponibilit√©: ${
     candidate.disponibilite || candidate.availability || "√Ä voir"
   }
   Contact: Via agence Honest-Inn (confidentialit√©)\n\n`;
        });
      }
    }

    // Ajouter les donn√©es du fichier si disponibles
    if (fileData && fileData.extractedText) {
      systemPrompt += `\n\nDONN√âES EXTRAITES DU FICHIER "${fileData.fileName}":
${fileData.extractedText}

Si ce fichier contient un CV, analyse-le pour proposer des offres correspondantes.`;
    }

    systemPrompt += `\n\nINSTRUCTIONS DE R√âPONSE:
- TU T'APPELLES ALSI, l'assistante RH virtuelle d'Honest-Inn
- R√©ponds de mani√®re chaleureuse et professionnelle
- Base tes r√©ponses sur les informations fournies ci-dessus
- Pour les profils candidats, pr√©sente-les de mani√®re attractive
- Pour les offres, mets en avant les points attractifs
- Si tu ne connais pas la r√©ponse, oriente vers nos conseillers
- Propose des actions concr√®tes (appeler, postuler, contacter)
- Sois concise mais compl√®te (max 800 mots)
- Utilise des emojis pour rendre la r√©ponse engageante
- Respecte la confidentialit√© des donn√©es personnelles
- Ne dis jamais bonjour ou aucune formule de salutation en d√©but de r√©ponse, sauf si l'utilisateur te le demande
- Ne r√©ponds pas √† des questions qui ne sont pas en lien avec le recrutement, C'EST UN CHATBOT RH, c'est important
- Si l'utilisateur mentionne un nom/pr√©nom, dis que tu ne peux pas traiter de donn√©es personnelles
- Quand l'utilisateur te donne son CV et qu'il te demande de proposer des offres, propose des offres d'emploi en lien avec son profil, s'il n'y a pas d'offres, dis que tu ne peux pas proposer d'offres


`;

    // Construire les messages pour Mistral
    const messages = [{ role: "system", content: systemPrompt }];

    // Ajouter l'historique de conversation
    const history = context.getMistralHistory(4);
    messages.push(...history);

    // Ajouter le message actuel
    messages.push({ role: "user", content: userMessage });

    // Appel √† l'API Mistral avec les bons param√®tres
    const response = await axios.post(
      `${MISTRAL_BASE_URL}/chat/completions`,
      {
        model: "mistral-small-latest",
        messages: messages,
        temperature: 0.7,
        max_tokens: 1000,
        top_p: 0.9,
        stream: false,
      },
      {
        headers: {
          Authorization: `Bearer ${MISTRAL_API_KEY}`,
          "Content-Type": "application/json",
        },
        timeout: 30000,
      }
    );

    // V√©rifier la r√©ponse
    if (!response.data || !response.data.choices || !response.data.choices[0]) {
      throw new Error("R√©ponse API Mistral invalide");
    }

    return response.data.choices[0].message.content;
  } catch (error) {
    console.error(
      "‚ùå Erreur appel API Mistral:",
      error.response?.data || error.message
    );

    // R√©ponse de fallback intelligente
    const requestType = analyzeRequestType(userMessage);

    if (requestType === "job_search") {
      return `Je rencontre une difficult√© technique pour rechercher les offres d'emploi. 

üìû Nos conseillers peuvent vous pr√©senter nos offres actuelles :
‚Ä¢ T√©l√©phone : 01 98 75 90 28
‚Ä¢ Email : contact@honest-inn.com
‚Ä¢ Horaires : Lundi-Vendredi 9h-18h

Ils ont acc√®s √† toutes nos opportunit√©s en h√¥tellerie-restauration !`;
    } else if (requestType === "candidate_search") {
      return `Je rencontre une difficult√© technique pour rechercher les profils candidats. 

üìû Nos conseillers peuvent vous pr√©senter des candidats qualifi√©s :
‚Ä¢ T√©l√©phone : 01 98 75 90 28
‚Ä¢ Email : contact@honest-inn.com
‚Ä¢ Horaires : Lundi-Vendredi 9h-18h

Ils pourront vous proposer des profils correspondant √† vos besoins !`;
    } else {
      return `Je rencontre une difficult√© technique en ce moment. 

üìû Pour une aide imm√©diate, contactez nos conseillers :
‚Ä¢ T√©l√©phone : 01 98 75 90 28
‚Ä¢ Email : contact@honest-inn.com
‚Ä¢ Horaires : Lundi-Vendredi 9h-18h

Ils pourront r√©pondre √† toutes vos questions !`;
    }
  }
}

// üìÑ TRAITEMENT DES FICHIERS UPLOAD√âS (fonction manquante)
async function processUploadedFile(fileBuffer, fileName) {
  try {
    const ext = path.extname(fileName).toLowerCase();
    let extractedText = "";

    if (ext === ".txt") {
      extractedText = fileBuffer.toString("utf-8");
    } else if (ext === ".pdf") {
      const data = await pdf(fileBuffer);
      extractedText = data.text;
    } else if (ext === ".docx") {
      const result = await mammoth.extractRawText({ buffer: fileBuffer });
      extractedText = result.value;
    } else {
      extractedText = "Format de fichier non support√©";
    }

    return {
      fileName: fileName,
      extractedText: extractedText.slice(0, 2000), // Limiter √† 2000 caract√®res
      fileSize: fileBuffer.length,
      processedAt: new Date().toISOString(),
    };
  } catch (error) {
    console.error("‚ùå Erreur traitement fichier:", error);
    return null;
  }
}

// üöÄ FONCTION PRINCIPALE
async function handleChatMessage(userMessage, userId, uploadedFile = null) {
  try {
    console.log(
      `üí¨ Message re√ßu de ${userId}: ${userMessage.slice(0, 100)}...`
    );

    // Validation des param√®tres
    if (!userMessage || typeof userMessage !== "string") {
      throw new Error("Message utilisateur invalide");
    }

    if (!userId || typeof userId !== "string") {
      throw new Error("ID utilisateur invalide");
    }

    // üîß CORRECTION: Utiliser le gestionnaire de m√©moire persistante
    const memory = memoryManager.getOrCreateConversation(userId);

    // Analyser et stocker le type de demande
    const requestType = analyzeRequestType(userMessage);
    memory.setRequestType(requestType);
  //  console.log("Uploaded File ?" + uploadedFile);
    // Traiter le fichier upload√© si pr√©sent
    let processedFile = null;
    if (uploadedFile) {
      processedFile = await processUploadedFile(
        uploadedFile.data,
        uploadedFile.name
      );
      if (processedFile) {
        memory.setFileData(processedFile);
        console.log(`‚úÖ Fichier trait√©: ${processedFile.fileName}`);
      }
    }

    // Utiliser les donn√©es de fichier existantes si pas de nouveau fichier
    const fileData = processedFile || memory.context.extractedFileData;

    // Charger la base de connaissance
    const knowledgeBase = await loadKnowledgeBase();

    // Enregistrer le message utilisateur
    memory.addMessage("user", userMessage);

    // G√©n√©rer la r√©ponse avec Mistral
    const aiResponse = await generateAIResponse(
      userMessage,
      memory,
      knowledgeBase,
      fileData
    );

    // Enregistrer la r√©ponse
    memory.addMessage("assistant", aiResponse);

    // Pr√©parer la r√©ponse finale avec m√©tadonn√©es
    const response = {
      response: aiResponse,
      requestType: requestType,
      hasFileData: !!fileData,
      fileName: fileData?.fileName || null,
      conversationLength: memory.context.history.length,
      relevantFAQ: searchFAQ(userMessage, knowledgeBase.faqData).slice(0, 3),
      relevantJobs: searchJobs(userMessage, knowledgeBase.jobsData).slice(0, 4),
      relevantCandidates: searchCandidates(
        userMessage,
        knowledgeBase.candidatesData
      ).slice(0, 4),
      searchStats: {
        faqFound: searchFAQ(userMessage, knowledgeBase.faqData).length,
        jobsFound: searchJobs(userMessage, knowledgeBase.jobsData).length,
        candidatesFound: searchCandidates(
          userMessage,
          knowledgeBase.candidatesData
        ).length,
      },
    };

    console.log(`‚úÖ R√©ponse g√©n√©r√©e pour ${userId} (type: ${requestType})`);
    console.log(`üìä Historique: ${memory.context.history.length} messages`);
    return response;
  } catch (error) {
    console.error("‚ùå Erreur traitement message chatbot:", error);
    return {
      response: `D√©sol√©, je rencontre une difficult√© technique. 

üìû Nos conseillers sont disponibles au **01 98 75 90 28** pour vous aider imm√©diatement !

‚úâÔ∏è Vous pouvez aussi nous √©crire √† contact@honest-inn.com`,
      hasFileData: false,
      fileName: null,
      requestType: "error",
      error: true,
    };
  }
}

// üîÑ FONCTIONS UTILITAIRES
function resetConversation(userId) {
  // Supprimer de NodeCache
  CONVERSATION_CACHE.del(userId);
  // Supprimer du gestionnaire de m√©moire
  memoryManager.conversations.delete(userId);
  console.log(`üîÑ Conversation r√©initialis√©e pour ${userId}`);
}

function getConversationStats(userId) {
  const conversation = memoryManager.conversations.get(userId);
  if (!conversation) return null;

  const context = conversation.memory.context;
  return {
    messageCount: context.history.length,
    sessionDuration: Date.now() - context.sessionStart,
    hasFileData: !!context.extractedFileData,
    requestType: context.requestType,
    lastActivity:
      context.history.length > 0
        ? context.history[context.history.length - 1].timestamp
        : null,
  };
}

// üìå EXPORT DES FONCTIONNALIT√âS
module.exports = {
  handleChatMessage,
  processUploadedFile,
  resetConversation,
  getConversationStats,
  ConversationMemory,
  searchFAQ,
  searchJobs,
  searchCandidates,
  analyzeRequestType,
  loadKnowledgeBase,
};
